"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionComposer = void 0;
const crypto_1 = require("@near-js/crypto");
const transactions_1 = require("@near-js/transactions");
const utils_1 = require("@near-js/utils");
class TransactionComposer {
    actions = [];
    receiver;
    sender;
    blockHash;
    nonce;
    publicKey;
    constructor(transaction) {
        this.receiver = transaction.receiver;
        this.sender = transaction.sender;
        this.blockHash = transaction.blockHash;
        this.nonce = transaction.nonce;
        this.publicKey = transaction.publicKey;
    }
    /**
     * Initialize the composer
     * @param transaction composer configuration
     */
    static init(transaction) {
        return new TransactionComposer(transaction);
    }
    /**
     * Validate and return the object used for Transaction instantiation
     * @param transaction transaction values to override composed transaction fields
     * @private
     */
    buildTransactionObject(transaction) {
        const tx = {
            actions: this.actions,
            blockHash: (0, utils_1.baseDecode)(transaction?.blockHash || this.blockHash),
            nonce: transaction?.nonce || this.nonce,
            publicKey: transaction?.publicKey || this.publicKey,
            receiverId: transaction?.receiver || this.receiver,
            signerId: transaction?.sender || this.sender,
        };
        if (!tx.actions.length || !tx.blockHash || !tx.nonce || !tx.publicKey || !tx.receiverId || !tx.signerId) {
            throw new Error(`invalid transaction: ${JSON.stringify(tx)}`);
        }
        return tx;
    }
    /**
     * Return a Transaction instance from the composed transaction
     * @param transaction transaction configuration to override values set at composer initialization
     */
    toTransaction(transaction) {
        return new transactions_1.Transaction(this.buildTransactionObject(transaction));
    }
    /**
     * Add an action to add a full access key
     * @param publicKey string representation of the public key on the new access key
     */
    addFullAccessKey(publicKey) {
        this.actions.push(transactions_1.actionCreators.addKey(crypto_1.PublicKey.from(publicKey), transactions_1.actionCreators.fullAccessKey()));
        return this;
    }
    /**
     * Add an action to create a function call access key
     * @param publicKey string representation of the public key on the new access key
     * @param contractId permitted contract
     * @param methodNames set of permitted methods
     * @param allowance max allowable balance attached to transactions signed with this key
     */
    addFunctionCallAccessKey(publicKey, contractId, methodNames, allowance) {
        const accessKey = transactions_1.actionCreators.functionCallAccessKey(contractId, methodNames, allowance);
        this.actions.push(transactions_1.actionCreators.addKey(crypto_1.PublicKey.from(publicKey), accessKey));
        return this;
    }
    /**
     * Add an action to create a sub-account for the transaction recipient
     */
    createAccount() {
        this.actions.push(transactions_1.actionCreators.createAccount());
        return this;
    }
    /**
     * Add an action to delete the account signing the composed transaction
     * @param beneficiaryId designated recipient account for any remaining balance on the deleted account
     */
    deleteAccount(beneficiaryId) {
        this.actions.push(transactions_1.actionCreators.deleteAccount(beneficiaryId));
        return this;
    }
    /**
     * Add an action to delete the specified access key
     * @param publicKey string representation of the public key on the access key to be deleted
     */
    deleteKey(publicKey) {
        this.actions.push(transactions_1.actionCreators.deleteKey(crypto_1.PublicKey.from(publicKey)));
        return this;
    }
    /**
     * Add an action to deploy code to a contract
     * @param code compiled smart contract binary
     */
    deployContract(code) {
        this.actions.push(transactions_1.actionCreators.deployContract(code));
        return this;
    }
    /**
     * Add an action to invoke a smart contract method
     * @param method name of the method to be executed
     * @param args named arguments to the invocation
     * @param gas amount of gas (in yN) included to cover execution cost
     * @param deposit amount of Near (in yN) to attach to the invocation
     */
    functionCall(method, args, gas = utils_1.DEFAULT_FUNCTION_CALL_GAS * BigInt(10), deposit = BigInt(0)) {
        this.actions.push(transactions_1.actionCreators.functionCall(method, args, gas, deposit));
        return this;
    }
    /**
     * Add an action wrapping a delegate action for inclusion in meta transaction
     * @param delegateAction delegate action encapsulating the set of actions to be executed on the requesting account's behalf
     * @param signature signature of the delegate action signed by the requesting account
     */
    signedDelegate(delegateAction, signature) {
        this.actions.push(transactions_1.actionCreators.signedDelegate({ delegateAction, signature }));
        return this;
    }
    /**
     * Add an action to stake Near with a validator
     * @param stake amount of Near (in yN) to stake
     * @param publicKey string representation of the validator's key
     */
    stake(stake, publicKey) {
        this.actions.push(transactions_1.actionCreators.stake(stake, crypto_1.PublicKey.from(publicKey)));
        return this;
    }
    /**
     * Add an action to transfer Near to another account
     * @param deposit amount of Near (in yN) to transfer
     */
    transfer(deposit) {
        this.actions.push(transactions_1.actionCreators.transfer(deposit));
        return this;
    }
}
exports.TransactionComposer = TransactionComposer;
