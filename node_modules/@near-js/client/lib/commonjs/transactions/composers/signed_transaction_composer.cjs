"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SignedTransactionComposer = void 0;
const transactions_1 = require("@near-js/transactions");
const utils_1 = require("@near-js/utils");
const constants_1 = require("../../constants.cjs");
const sign_and_send_1 = require("../sign_and_send.cjs");
const transaction_composer_1 = require("./transaction_composer.cjs");
const signers_1 = require("../../signing/signers.cjs");
class SignedTransactionComposer extends transaction_composer_1.TransactionComposer {
    messageSigner;
    rpcProvider;
    signer;
    constructor({ deps, ...baseOptions }) {
        super(baseOptions);
        this.messageSigner = deps.signer;
        this.rpcProvider = deps.rpcProvider;
        if (this.sender) {
            this.signer = (0, signers_1.getAccessKeySigner)({ account: this.sender, deps });
        }
    }
    /**
     * Initialize the composer
     * @param options signed composer configuration
     */
    static init(options) {
        return new SignedTransactionComposer(options);
    }
    /**
     * Return a signed delegate action encapsulating the composed transaction for inclusion in a meta transaction
     * @param transaction meta transaction configuration
     */
    async toSignedDelegateAction(transaction) {
        let maxBlockHeight = transaction?.maxBlockHeight;
        if (!maxBlockHeight) {
            const { header } = await this.rpcProvider.block({ finality: 'final' });
            const ttl = transaction?.blockHeightTtl || constants_1.DEFAULT_META_TRANSACTION_BLOCK_HEIGHT_TTL;
            maxBlockHeight = BigInt(header.height) + ttl;
        }
        const delegateAction = (0, transactions_1.buildDelegateAction)({
            actions: this.actions,
            maxBlockHeight,
            nonce: transaction?.nonce || this.nonce || await this.signer.getNonce(),
            publicKey: transaction?.publicKey || this.publicKey || await this.signer.getPublicKey(),
            receiverId: transaction?.receiver || this.receiver,
            senderId: transaction?.sender || this.sender,
        });
        const { signedDelegateAction } = await (0, transactions_1.signDelegateAction)({
            delegateAction,
            signer: { sign: (m) => this.signer.signMessage(m) },
        });
        return signedDelegateAction;
    }
    /**
     * Verify the transaction's signer matches the account mapped to the AccessKeySigner.
     *  Initialize the signer if not already done (i.e. for lazy setting of the transaction signer).
     *  Throw an error if there is a mismatch between the current AccessKeySigner and the transaction's specified signer.
     * @param signingAccount
     * @private
     */
    verifySigner(signingAccount) {
        if (!this.signer) {
            this.signer = (0, signers_1.getAccessKeySigner)({
                account: signingAccount,
                deps: { rpcProvider: this.rpcProvider, signer: this.messageSigner },
            });
        }
        const signerAccount = this.signer.getSigningAccount();
        if (signingAccount !== signerAccount) {
            throw new Error(`Cannot sign transaction as ${signingAccount} with AccessKeySigner for ${signerAccount}`);
        }
    }
    /**
     * Return a signed transaction from the composed transaction
     * @param transactionOptions transaction configuration to override values set at composer initialization
     */
    async toSignedTransaction(transactionOptions) {
        const transaction = this.toTransaction(transactionOptions);
        this.verifySigner(transaction.signerId);
        return (0, sign_and_send_1.signTransaction)({
            transaction,
            deps: { signer: this.signer },
        });
    }
    /**
     * Sign and send the composed transaction
     * @param blockReference block to use for determining hash
     */
    async signAndSend(blockReference = { finality: 'final' }) {
        this.verifySigner(this.sender);
        const { signedTransaction } = await this.toSignedTransaction({
            nonce: this.nonce || await this.signer.getNonce(),
            publicKey: this.publicKey || await this.signer.getPublicKey(),
            blockHash: this.blockHash || (await this.rpcProvider.block(blockReference))?.header?.hash,
        });
        const outcome = await this.rpcProvider.sendTransaction(signedTransaction);
        return {
            outcome,
            result: (0, utils_1.getTransactionLastResult)(outcome),
        };
    }
}
exports.SignedTransactionComposer = SignedTransactionComposer;
