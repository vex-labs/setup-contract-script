"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getStakedBalance = exports.getNonce = exports.getContractState = exports.getContractCode = exports.getAccessKeys = exports.getAccountState = exports.getAccessKey = exports.view = exports.callViewMethod = exports.query = void 0;
const DEFAULT_VIEW_BLOCK_REFERENCE = { finality: 'optimistic' };
var RequestType;
(function (RequestType) {
    RequestType["CallFunction"] = "call_function";
    RequestType["ViewAccessKey"] = "view_access_key";
    RequestType["ViewAccessKeyList"] = "view_access_key_list";
    RequestType["ViewAccount"] = "view_account";
    RequestType["ViewCode"] = "view_code";
    RequestType["ViewState"] = "view_state";
})(RequestType || (RequestType = {}));
/**
 * Make a readonly request to an RPC endpoint targeting a specific account/contract
 * @param account target account/contract being queried
 * @param request type of request (e.g. `call_function`)
 * @param args named arguments passed in the request body
 * @param blockReference block ID/finality
 * @param rpcProvider RPC provider instance
 */
function query({ account, request, args = {}, blockReference, deps: { rpcProvider }, }) {
    return rpcProvider.query({
        request_type: request,
        account_id: account,
        ...(blockReference ? blockReference : DEFAULT_VIEW_BLOCK_REFERENCE),
        ...args,
    });
}
exports.query = query;
/**
 * Call a view method on an account/contract, returning the raw response
 * @param account target account/contract being queried
 * @param method name of the method being invoked
 * @param args named arguments passed in the request body
 * @param blockReference block ID/finality
 * @param deps readonly RPC dependencies
 */
function callViewMethod({ account, method, args = {}, blockReference, deps }) {
    return query({
        request: RequestType.CallFunction,
        account,
        args: {
            args_base64: Buffer.isBuffer(args) ? args : Buffer.from(JSON.stringify(args)).toString('base64'),
            method_name: method,
        },
        blockReference,
        deps,
    });
}
exports.callViewMethod = callViewMethod;
/**
 * Call a view method on an account/contract, parsing the returned data
 * NB if the data returned is a byte array, this method will convert it
 *  to string - use `await (viewRaw(...)).result` to get the buffer
 * @param account target account/contract being queried
 * @param method name of the method being invoked
 * @param args named arguments passed in the request body
 * @param blockReference block ID/finality
 * @param deps readonly RPC dependencies
 */
async function view({ account, method, args = {}, blockReference, deps }) {
    const { result } = await callViewMethod({ account, method, args, blockReference, deps });
    const stringResult = Buffer.from(result).toString();
    try {
        return JSON.parse(stringResult);
    }
    catch {
        const numeric = +stringResult;
        if (isNaN(numeric)) {
            return stringResult;
        }
        return (Number.isSafeInteger(numeric) ? numeric : BigInt(numeric));
    }
}
exports.view = view;
/**
 * Get metadata for the specified access key
 * @param account target account/contract being queried
 * @param publicKey public key string to be queried
 * @param blockReference block ID/finality
 * @param deps readonly RPC dependencies
 */
async function getAccessKey({ account, publicKey, blockReference, deps }) {
    const { nonce, permission } = await query({
        request: RequestType.ViewAccessKey,
        account,
        args: {
            public_key: publicKey,
        },
        blockReference,
        deps,
    });
    if (permission === 'FullAccess') {
        return {
            nonce: BigInt(nonce),
            publicKey,
        };
    }
    const { FunctionCall: { allowance, receiver_id, method_names } } = permission;
    return {
        allowance: BigInt(allowance),
        contract: receiver_id,
        methods: method_names,
        nonce: BigInt(nonce),
        publicKey,
    };
}
exports.getAccessKey = getAccessKey;
/**
 * Get account metadata (e.g. balance, storage)
 * @param account target account/contract being queried
 * @param blockReference block ID/finality
 * @param deps readonly RPC dependencies
 */
async function getAccountState({ account, blockReference, deps }) {
    const accountState = await query({
        request: RequestType.ViewAccount,
        account,
        blockReference,
        deps,
    });
    return {
        availableBalance: BigInt(accountState.amount),
        codeHash: accountState.code_hash,
        locked: BigInt(accountState.locked),
        storageUsed: BigInt(accountState.storage_usage),
    };
}
exports.getAccountState = getAccountState;
/**
 * Get list of access keys for the specified account/contract
 * @param account target account/contract being queried
 * @param blockReference block ID/finality
 * @param deps readonly RPC dependencies
 */
async function getAccessKeys({ account, blockReference, deps }) {
    const { keys } = await query({
        request: RequestType.ViewAccessKeyList,
        account,
        blockReference,
        deps,
    });
    return keys.reduce((accessKeys, { access_key: { nonce, permission }, public_key: publicKey }) => {
        if (permission === 'FullAccess') {
            accessKeys.fullAccessKeys.push({
                nonce,
                publicKey,
            });
        }
        else {
            const { FunctionCall: { allowance, receiver_id, method_names } } = permission;
            accessKeys.functionCallAccessKeys.push({
                allowance: BigInt(allowance),
                contract: receiver_id,
                methods: method_names,
                nonce,
                publicKey,
            });
        }
        return accessKeys;
    }, { fullAccessKeys: [], functionCallAccessKeys: [] });
}
exports.getAccessKeys = getAccessKeys;
/**
 * Get the code for the contract deployed to the target account
 * @param account target account/contract being queried
 * @param blockReference block ID/finality
 * @param deps readonly RPC dependencies
 */
async function getContractCode({ account, blockReference, deps }) {
    const { code_base64, hash } = await query({
        request: RequestType.ViewCode,
        account,
        blockReference,
        deps,
    });
    return { code: Buffer.from(code_base64, 'base64').toString(), code_base64, hash };
}
exports.getContractCode = getContractCode;
/**
 * Get the state on the contract deployed to the target account in key-value pairs
 * @param account target account/contract being queried
 * @param prefix target prefix filter (empty string/buffer returns all keys)
 * @param blockReference block ID/finality
 * @param deps readonly RPC dependencies
 * @returns object key-value pairs
 */
async function getContractState({ account, prefix, blockReference, deps }) {
    const { values } = await query({
        request: RequestType.ViewState,
        account,
        args: {
            prefix_base64: Buffer.from(prefix).toString('base64'),
        },
        blockReference,
        deps,
    });
    return values.reduce((state, { key, value }) => ({
        ...state,
        [key]: value,
    }), {});
}
exports.getContractState = getContractState;
/**
 * Get the nonce for the specified access key
 * @param account target account/contract being queried
 * @param publicKey public key string to be queried
 * @param blockReference block ID/finality
 * @param deps readonly RPC dependencies
 */
async function getNonce({ account, publicKey, blockReference, deps }) {
    const { nonce } = await getAccessKey({
        account,
        publicKey,
        blockReference,
        deps,
    });
    return BigInt(nonce);
}
exports.getNonce = getNonce;
/**
 * Get the balance staked with a validator
 * @param account the account staking Near with the validator
 * @param validator contract with which Near is staked
 * @param blockReference block ID/finality
 * @param deps readonly RPC dependencies
 */
async function getStakedBalance({ account, validator, blockReference, deps }) {
    const staked = await view({
        account: validator,
        blockReference,
        method: 'get_account',
        args: { account_id: account },
        deps,
    });
    return {
        canWithdraw: staked.can_withdraw,
        stakedBalance: BigInt(staked.staked_balance),
        unstakedBalance: BigInt(staked.unstaked_balance),
    };
}
exports.getStakedBalance = getStakedBalance;
