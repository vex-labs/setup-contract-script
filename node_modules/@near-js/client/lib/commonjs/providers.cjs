"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMainnetRpcProvider = exports.getTestnetRpcArchivalProvider = exports.getTestnetRpcProvider = exports.getProviderByEndpoints = exports.getProviderByNetwork = exports.createRpcClientWrapper = exports.getEndpointsByNetwork = void 0;
const providers_1 = require("@near-js/providers");
const constants_1 = require("./constants.cjs");
/**
 * Get the set of public endpoints for the provided network
 * @param network target blockchain network (e.g. `mainnet`)
 */
function getEndpointsByNetwork(network) {
    switch (network) {
        case 'testnet':
            return constants_1.PAGODA_RPC_ENDPOINTS_TESTNET;
        case 'mainnet':
            return constants_1.PAGODA_RPC_ENDPOINTS_MAINNET;
        default:
            return null;
    }
}
exports.getEndpointsByNetwork = getEndpointsByNetwork;
/**
 * Initialize a failover RPC provider capable of retrying requests against a set of endpoints
 * @param urls RPC endpoint URLs
 */
function createRpcClientWrapper(urls) {
    if (!urls) {
        throw new Error('at least one RPC endpoint URL required');
    }
    const provider = new providers_1.FailoverRpcProvider(urls.map((url) => new providers_1.JsonRpcProvider({ url })));
    return {
        block: (block) => provider.block(block),
        chunk: (chunkId) => provider.chunk(chunkId),
        getTransaction: ({ transactionHash, account, includeReceipts, waitUntil }) => {
            if (includeReceipts) {
                return provider.txStatusReceipts(transactionHash, account, waitUntil);
            }
            return provider.txStatus(transactionHash, account, waitUntil);
        },
        sendTransaction: (transaction) => provider.sendTransaction(transaction),
        query: (params) => provider.query(params),
    };
}
exports.createRpcClientWrapper = createRpcClientWrapper;
/**
 * Initialize a failover RPC provider for the given network
 * @param network target blockchain network (e.g. `mainnet`)
 */
function getProviderByNetwork(network) {
    return createRpcClientWrapper(getEndpointsByNetwork(network));
}
exports.getProviderByNetwork = getProviderByNetwork;
/**
 * Initialize a failover RPC provider for a set of RPC endpoint URLs
 * @param urls RPC endpoint URLs
 */
function getProviderByEndpoints(...urls) {
    return createRpcClientWrapper(urls);
}
exports.getProviderByEndpoints = getProviderByEndpoints;
/**
 * Initialize a testnet RPC provider
 */
function getTestnetRpcProvider() {
    return getProviderByNetwork('testnet');
}
exports.getTestnetRpcProvider = getTestnetRpcProvider;
/**
 * Initialize a testnet archival RPC provider
 */
function getTestnetRpcArchivalProvider() {
    return createRpcClientWrapper(constants_1.PAGODA_RPC_ARCHIVAL_ENDPOINTS_TESTNET);
}
exports.getTestnetRpcArchivalProvider = getTestnetRpcArchivalProvider;
/**
 * Initialize a mainnet RPC provider
 */
function getMainnetRpcProvider() {
    return getProviderByNetwork('mainnet');
}
exports.getMainnetRpcProvider = getMainnetRpcProvider;
